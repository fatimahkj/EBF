""" CSeq Program Analysis Framework
	source merging module

Author:
    Omar Inverso

Changes:
    2021.02.15  reading the input from the input file, not from a string anymore (improves linemapping)
    2020.12.29  using ASCII-encoded strings rather then UTF
    2020.12.21  Slight changes to support Python 3
    2020.03.24 (CSeq-2.0)
    2019.11.15 (CSeq-1.9) [SV-COMP 2020] pycparserext, general cleanup
    2019.11.15  removed all workarounds for sanitising code
    2018.10.27  no longer stripping the input file from un-necessary headers
    2015.10.20  patch for ldv-races category of SVCOMP16 (from 2_1 to 3_2)
    2015.07.12  new linemapping now mapping back from (outputline) -> (inputline,inputfile)
    2014.12.24 (CSeq-1.0beta)
    2014.10.09 (newseq-0.6a, newseq-0.6c) [SV-COMP 2015]
    2014.10.09  moved all parser-based code transformations from this module to  workarounds.py
    2014.10.09  modifying sanitise() to avoid using the preprocessor at that stage (easier line mapping)
    2014.09.27  new method sanitise() now includes all code-satinising, including thread_local workaround
    2014.09.22  moved thread local workaround from  new.py  to this module
    2014.09.22  load() / loadfromstring() now use gcc rather than cpp to preprocess,
                needed to avoid problems with OSX (where cpp does not remove C++-style comments, causing parsing errors)
    2014.02.25  switched to module.Module base class for modules

Notes: the line mapping mechanism is very different from the other modules
      (linemarkers are generated by the external preprocessor and thus follow
       a different logic)

Todo:
    It is no longer necessary to remove linemarkers from the input:
    linemarking should be updated accordinly.

"""

import getopt, inspect, os, re, sys, subprocess, shlex, time
import core.module, core.utils


class Merger(core.module.Translator):
	inputtooutput = {}		# input lines to output lines
	outputtoinput = {}		# output lines to input lines
	outputtofiles = {}		# output lines to input file names


	def loadfromstring(self,string,env):
		self.cseqenv = env
		self.input = string

		# Pass on to the rest of the chain of modules
		# the list of system headers extracted before merging.
		# Used e.g. when instrumenting.
		#
		self.setoutputparam('systemheaders', self.getsystemheaders(string))

		#string = self._sanitiseinput(string)
		#string = self._gnu_extension_fix(string)
		# Run the preprocessor with linemarker generation.
		#
		# the linemarker has the following format
		# (see https://gcc.gnu.org/onlinedocs/gcc-4.3.6/cpp/Preprocessor-Output.html):
		#
		#   # LINE_NO FILENAME FLAG
		#
		# examples:
		#  # 1 "<stdin>"
		#  # 1 "include/pthread.h" 2
		#
		includestring = ' -I%s' % os.path.dirname(__file__)+'/include' # include fake headers first
		localincludepath = env.inputfile[:env.inputfile.rfind('/')] if '/' in env.inputfile else ''

		if localincludepath!='': includestring += ' -I%s' % localincludepath
		if env.includepath: includestring += ' -I'+' -I'.join(env.includepath.split(':'))

		# Pre-process away GNU C extensions.
		#macros = "-D'__attribute__(x)=' -D'__extension__(x)=' -D'__volatile__=' -D'__asm__(x)='"
		macros = "-D'__attribute__(x)=' -D'__extension__(x)=' -D'__volatile__='"

		# Note: cpp does not strip C++-style comments ('//') from the input code, gcc instead does.
		#cmdline = 'cpp -Iinclude -E -C ' + filename + ' > ' + filename + '.1' + '.c'
		#cmdline = 'gcc -Iinclude -P -E - '  # hyphen at the end forces input from stdin
		cmdline = 'gcc %s -nostdinc %s -E -' % (macros,includestring) # hyphen at the end forces input from stdin
		#######cmdline = 'gcc %s -nostdinc %s -E %s' % (macros,includestring,env.inputfile)
		p = subprocess.Popen(shlex.split(cmdline), stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
		# string = p.communicate(input=string)[0] # python 2.7
		#string = p.communicate(input=string.encode('ascii'))[0] # python 3
		string = p.communicate(input=string.encode())[0] # python 3

		# After preprocessing, line markers indicate where the lines come from, but
		# this information needs to be removed from the input block, or
		# pycparser won't handle it.
		#
		string = string.decode()
		input = string.splitlines()

		output = ''             # clean input (without linemarkers)
		outputlineno = 0        # current output line number (clean, no linemarkers)
		inputlinenooffset = 0   # number of input lines since the last marker

		# coords fetched from the last linemarker
		lastinputfile = ''      # input file from the last linemarker
		lastinputlineno = 0     # line number from the last linemarker

		extension_re = re.compile(r'\b__extension__\b')  # SV-COMP2022

		for line in input:
			if line.startswith('# '):
				inputlinenooffset = -1
				(lastinputlineno,lastinputfile,lastflag) = core.utils.linemarkerinfo(line)
			else:
				#  > > >   Our line map   < < <
				outputlineno += 1
				inputlinenooffset += 1
				self.outputtoinput[outputlineno] = lastinputlineno+inputlinenooffset
				self.outputtofiles[outputlineno] = lastinputfile if lastinputfile!='<stdin>' else env.inputfile
				#print "KOKOKO [%s] %s,%s <- %s" % (line,self.outputtoinput[outputlineno],self.outputtofiles[outputlineno],outputlineno)
				line = extension_re.sub('', line)
				output += line + '\n'

		self.markedoutput = string
		self.output = output
		self.lastoutputlineno = outputlineno


	''' Check whether a given header file belongs to the set of the fake ones
	'''
	def issystemheader(self, filename):
		fake_include = os.path.dirname(__file__)+'/include/'

		if os.path.isfile(fake_include+filename): return True
		else: return False


	''' Extract from the input source file the list of system headers
	'''
	def getsystemheaders(self, input):
		headers = ''

		for l in input.splitlines():
			m = re.match(r'[ \t]*#[ \t]*include[ \t]*[\"<](.+)[\">]', l)

			if m:
				header = m.group(1)

				if (self.issystemheader(header) and header != 'pthread.h'):
					headers += "#include <%s>\n" % header

		return headers


	''' Override generic line mapping
	'''
	def getlinenumbertable(self):
		str = ''

		for i in range(1,self.lastoutputlineno):
			if i in self.outputtoinput:
				str += "%s,%s <- %s\n" % (self.outputtoinput[i],self.outputtofiles[i], i)

		return str


	def show(self):
		print(self.output)





